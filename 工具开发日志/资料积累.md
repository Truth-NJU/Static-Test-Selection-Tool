[TOC]



# 1. STARTS: *STA*tic *R*egression *T*est *S*election

1.  抽象回归测试是软件开发的重要组成部分，但是它非常耗时。回归测试选择(RTS)的目标是**通过只运行受影响的测试来加速回归测试**——这些测试的子集可能由于代码更改而改变行为。我们提出了开始，一个静态回归测试选择的工具。与动态RTS不同，启动不需要代码检测或运行时信息来查找受影响的测试;相反，**STARTS只使用编译时信息。具体来说，STARTS构建程序类型的依赖关系图，并根据影响查找可以在依赖关系图的传递闭包中达到某些已更改类型的测试。**STARTS是一个Maven插件，可以轻松集成到任何基于Maven的Java项目中。我们发现，start平均选择35.2%的测试，导致端到端运行时平均运行所有测试的81.0%。
2. 回归测试是软件开发的重要组成部分。在每次代码更改之后，开发人员运行回归测试套件中的测试，以确保更改不会破坏任何现有功能。然而，当回归测试套件包含许多测试时，在每次更改之后运行所有测试(通常称为RetestAll)非常耗时，并减慢了软件开发过程。回归测试选择(RTS)是通过选择只运行受更改影响的测试来降低回归测试成本的一种方法。RTS技术的工作原理是**找到每个测试的依赖关系，并选择依赖于更改的测试。运行更少但必要的测试可以加快回归测试，同时确保不会错过任何测试失败。**

3.  **STARTS构造一个与所有类型相关的的依赖关系图(包括类、接口和枚举)，并为每个测试计算一个传递闭包，以找到它的依赖项。STARTS通过计算每个类型对应的已编译类文件的校验和，并将计算得到的校验和与上一次运行中计算得到的校验和进行比较，来确定更改的类型**。 STARTS选择运行受影响的测试，这些测试的传递依赖项包括一些已更改的类型。我们增加了对多模块Maven项目的支持，并提高了速度，包括解析常量池而不是整个类文件，将依赖项保存为类型到测试而不是测试到类型，使用更快的图形库，以及增量缓存依赖项。
4. 开发人员可以使用start执行几个与rts相关的任务:
   1. 发现在字节码级别改变语义类型
   2. 发现的类型(不仅仅是测试)变化的影响(例如,改变-影响分析),
   3. 在没有运行这些测试的情况下，发现受更改影响的测试
   4. 找到并运行测试影响的变化。
5. 实现的目标
   1. starts:help 列出starts所有的目标和它们的用途。
   2. starts:diff 显示自上次运行Starts以来更改的所有Java类型(包括类、接口和枚举)。
   3. starts:impacted 显示所有受变更影响的类型(不仅仅是测试类)，从而为变更影响分析提供了一种方法。
   4. starts:select 显示(但不运行)自上次starts运行以来受更改影响的测试类—允许开发人员更灵活地首先选择受影响的测试，然后在稍后运行这些测试。
   5. starts:starts 运行受影响的测试;它执行先前与rts相关的目标的功能，并执行受影响的测试。
   6. starts:clean. 删除从上一次运行(在.starts目录中)中存储的所有starts工件，重新设置starts，以便在下一次运行时，认为所有类型都已更改(如果使用starts:starts，则选择所有测试运行)。
6.  starts提供了几个选项，为用户提供了一些灵活性。最重要的选项是在调用目标后是否更新starts工件。如第III-B节所述，STARTS跟踪上次运行的所有类型的校验和，将它们存储到磁盘，并在新的运行中使用它们来查找受影响的测试。在启动中所有与rts相关的目标都提供了一个更新∗checksum选项，当该选项为true时，在运行后更新存储的校验和。对于目标starts:starts，该选项默认设置为true，但对于所有其他目标，默认设置为false。
7.  因此，我们实现了**基于类防火墙的类级SRTS（静态回归测试选择）**的Starts，它包含了需要重新测试的类型，因为它们可能会受到代码更改的影响。类防火墙是在一个类型依赖图(TDG)上计算的，其中**每个节点都是应用程序中的一个类型**，如果τ直接使用或继承依赖于τ'，则从一个类型τ到另一个类型τ'有向边。测试类节点也包含在TDG中。如果τc是已更改的类型，则τ受到τc的影响当且仅当⟨τ，τc⟩∈E∗，其中E是TDG中所有边的集合，而∗表示自反和传递闭包。 类防火墙是所有类型的集合,可以通过传递到达在TDG中的任何类型。
8. 给定应用程序中所有类型的类文件(从编译新版本中获得)和先前版本的类文件的校验和。STARTS可以输出更改类型集(Tc)、类防火墙(防火墙(Tc))和Ti(受影响的测试集)。Ti计算为新修订中的所有测试集与不在防火墙中的测试集(Tc)之间的集差(Tc是从旧修订中计算的)。我们以这种方式计算Ti，以便它包括任何新添加的测试，同时仍然使用在旧版本上计算的TDG。

## 1.1 Starts实现

图1显示了STARTS体系结构，它包含以下组件:(i)查找应用程序中类型之间的依赖关系，(ii)构造TDG， (iii)查找应用程序的两个修订之间已更改的类型，(iv)存储当前修订中所有类型的校验和，(v)选择受更改类型影响的测试，(vi)运行受影响的测试。

1. **查找类型之间的依赖关系**：
   - starts需要计算应用程序中所有**类型之间的依赖关系**。
   - 我们之前的工作中的原型使用ASM来解析给定类型的已编译类文件中的所有字节码，以便计算其依赖项。然而，解析整个类文件只是为了找到依赖项是相当缓慢的，因为它需要递归地访问每个类型的字段、方法、签名和注释来收集所引用的所有类型。
   - **starts通过只读取每个类文件中的常量池来确定类文件中的类型可能依赖的所有类型，从而改进了类型之间的计算依赖关系**。 我们使用最新的Oracle **jdeps**工具来读取常量池。在将应用程序的新修订编译为生成类文件之后，STARTS进行单个jdeps调用(通过jdeps API)来一次解析应用程序中的所有类文件，然后在内存中处理jdeps输出，以找到每种类型的依赖项。
2. **构建类型之间的依赖图**
   - *type-dependency graph (TDG)*
   - TDG包含从一种类型到它的每个依赖项的边。我们使用一个名为**yasgl**的自定义图形库来构造图形，并查找可以传递到某些已更改类型的测试。**我们将每种类型作为一个节点添加到yasgl图中，并添加由jdeps计算的依赖项作为图中节点之间的边。**
   - 使用yasgl图，STARTS计算每个测试类的传递闭包，以找到每个测试所依赖的所有类型。我们最初的原型使用了JGraphT，但是yasgl在计算传递闭包方面更快。例如，yasgl需要1.4秒来计算一个包含41,960个节点和509,946条边的图的传递闭包(来自一个拥有110个测试类的项目的单个模块)。JGraphT需要2.7秒来计算同一个传递闭包，当考虑到项目中的所有模块时，这种差异会不断累积。  请注意，**Starts使用的yasgl TDG不区分使用边和继承边**。
3. **查找已更改的类型**
   - STARTS查找自上次运行以来已更改的类型。
   - STARTS使用Ekstazi中的相同校验和函数来计算一个校验和，该校验和忽略每个类文件的调试相关信息，并将校验和存储到一个文件中。STARTS跟踪类文件中的变化，因为相应的源文件可能不同，但结果可能是实际执行的同一个类文件，因此跟踪类文件更精确。
   - 此外，STARTS程序**使用校验和来检查类文件是否被修改**，而不是看起来更快的方法，如时间戳，这可能是不可靠的(例如，Maven的增量构建系统被破坏了，经常在每次运行时重新编译每个类型，因此不能依赖类文件的时间戳)。
   - **在新版本中编译完成后，STARTS将计算所有已编译类文件的校验和，并将其与前一个版本中计算的存储校验和进行比较。如果新旧校验和不同，则STARTS认为该类型已更改**。
   - 如果该类型以前没有计算过的校验和(即，添加了一个新类型)，那么它的校验和将被存储以备将来运行。最后，如果在新版本中找不到先前为其计算校验和的类型(即删除了旧类型)，那么该类型将不再存储在校验和文件中以备将来运行。如果磁盘上没有校验和文件(例如，在第一次运行时，或者在运行mvn starts:clean之后)，starts会认为所有类型都已更改。
4. **计算和存储校验和**
   - 在我们最初的原型类型中，以及在Ekstazi中，图中每个测试类的传递闭包被存储为从每个测试类到它的依赖关系的映射，即测试到类型的映射。而且，每个测试有一个依赖文件。一旦一个工具计算已更改的类型集，然后检查每个测试的依赖项文件，看看测试是否依赖于任何更改的类型。 然而，我们观察到，由于静态分析固有的不精确性，与Ekstazi相比，**STARTS发现了更多的测试依赖项，而且许多测试共享了很多这些依赖项**。因此，我们在STARTS中**反转了依赖项存储格式**，通过**存储类型到测试的映射来减少对测试依赖项的重复检查**。 
   - 在单个文件中STARTS存**储从应用程序中的每个类型到依赖于该类型的测试集的映射**。该文件存储在应用程序根目录下名为.starts的目录中。更准确地说，如果应用程序是一个基于maven的**多模块项目**，那么STARTS会在每个模块下创建多个. starts目录，每个目录都有自己的类型到测试的映射文件，如果是依赖关系导致的，这些类型可以跨模块。在对新修订调用STARTS目标之后，可以打开或关闭存储在磁盘上的校验和。
   - start使用的“类型到测试”存储方式，加上只处理磁盘上的一个文件，极大地提高了选择受影响测试的性能。对测试到类型格式的一种可能的修改是，首先读取所有文件，然后在比较校验和之前将类型到测试的映射(在内存中)颠倒过来。然而,这一修改仍然会产生阅读的成本可能许多文件从磁盘,和它将mapping-reversal过程关键路径从测试开始时到开发人员获得测试results-mapping逆转开始可能发生在一个单独的离线阶段不是在关键路径。
5. **选择受影响测试**
   - STARTS使用来自上一个版本的类型到测试依赖关系映射和所有已更改类型集，以查找不受更改影响的测试。然后开始计算受影响测试，将其作为当前修订中的所有测试集与非受影响测试集之间的差值。因此，新添加的测试总是在受影响的测试集中。查找受影响测试不需要在新修订上构造依赖关系图(允许更快地计算受影响测试)。 相反，STARTS读取类型到测试依赖项文件，该文件是根据上一版本中构建的依赖项图计算的。
   - 事实上，**STARTS只需要编译时信息就可以找到受影响的测试**，这允许阶段的清晰分离:
     - 分析阶段：查找更改和受影响的测试
     - 执行阶段：运行受影响的测试
     - 图计算阶段：构建依赖关系图，并使用它为下一个版本创建类型到测试的映射
     - 这种分离可以选择在“联机模式”(a、e和g相同时运行)或“脱机模式”(a和e相可以单独运行或与g相并行运行)运行STARTS。我们还没有实现切换在线/离线模式的目标，但报告离线模式的时间为在线模式的时间减去g阶段的时间。starts:select显示受影响的测试，但不运行它们。
6. **运行受影响测试**:
   - STARTS按前面描述的方式计算要运行的选定测试集：它将没有受到影响的测试排除在应用程序中的所有测试集之外。具体来说，STARTS会动态地将未受影响的测试添加到Surefire插件已经配置为不运行的测试集中。因此，当STARTS调用Maven Surefire插件来运行测试时，Surefire将只运行受更改影响的测试。
   - 目标starts:starts将执行前面的所有步骤，以查找更改的类型、选择受影响的测试并运行那些选定的测试。

## 1.2 重要的Starts选项

1. 除了打开/关闭校验和文件更新之外，STARTS还提供了许多其他选项。

2. **缓存jdeps输出:**

   - 在STARTS的设计中，需要考虑的一个问题是如何处理在第三方库(jar)上运行jdeps的输出。

   - 许多项目并不经常更改它们的库版本，并且使用jdeps来解析每个修订版上的库代码将不必要地重复工作。

   - 因此，STARTS提供了以下选项:(i)使用预处理缓存，(ii)在每个修订上增量地构建缓存，以及(iii)在每个修订上解析第三方库。默认是在每个修订上递增地构建缓存。当STARTS在应用程序的类路径中遇到JAR时，它首先检查在应用程序的每个模块中找到的jdeps-cache目录中是否存在相应的jdeps输出文件。如果有，就开始读;否则，在JAR上运行jdeps，使用jdeps输出作为其当前进程并将该JAR的jdeps输出存储在jdeps-cache目录中的一个文件中。jdeps-cache目录中的文件名称与命名基于maven的项目的Group/ArtifactId/Revision约定相匹配，并且具有.graph扩展名。

   - 如果有缓存(可能是在其他地方计算的，甚至是从不同的应用程序中计算的)，可以配置STARTS来指定这个缓存的位置。下面的命令显示了如何使用带有预处理缓存的rts相关目标，其中${GRAPH_CACHE}是包含每个第三方库的预处理jdeps输出的目录，并且jdeps输出文件按照默认选项的描述进行组织:

     - mvn starts:starts −DgCache=${GRAPH_CACHE}

   - 如果没有缓存输入或缓存为空，则STARTS会在每个版本的所有库上运行jdeps。 

     **校验和和依赖项的文件格式**：STARTS支持两种格式来存储应用程序中所有类型的校验和以及依赖于它们的测试:新的类型到测试(ZLC)格式和旧的测试到类型(CLZ)格式(Ekstazi提出)。ZLC是started使用的默认文件格式。使用CLZ文件格式运行starts:

     - mvn starts:starts −DdepFormat=CLZ

   - **控制STARTS工件存储**: 配置不同的日志级别可以控制STARTS在运行时存储的信息量，其中日志级别与java.util.logging API中相同。当运行在默认的日志级别INFO上时, STARTS在运行期间只存储校验和和依赖文件以及.starts/deps.zlc。在级别FINEST上时, STARTS将存储它的所有文件:所有/受影响/不受影响的测试的列表、jdeps计算的依赖项、STARTS使用的类路径、STARTS内部构造的yasgl图以及更改的类型集。运行在日志级别FINER上时将只存储.starts/deps.zlc、受影响的测试集和所有测试集。在存储所有文件时运行STARTS:

     - mvn starts:starts −DstartsLogging=FINEST

## 1.3 类防火墙算法

1. 一种使用对象关系图(Object Relation Graph)来描述测试类和生产类之间关系的算法。对象关系图描绘了面向对象程序中存在的继承、聚合以及关联关系。
2. **引理1**:假设在继承层级(Inheritance Hierarchy)中，类A是类B的子类。当有且仅有B发生变动时，为了保证测试充分，除B之外，A也应该重新进行单元测试。
3. **引理2**:假设在聚合层级(Aggregation Hierarchy)中，类A是类B的一个聚合类。当有且仅有B发生变动时，为了保证测试充分，除B 之外，A也应该重新进行单元测试。
4. **引理3**:假设在关联层级(Association Hierarchy)中，类A与类B的关系满足下列条件之一:(1)类A访问了类B的数据成员;(2) 类A需要向B传递信息。当B发生变动时，为了保证测试充分，除B之外，A也应该重新进行测试。同时，类A还应该与类B进行重新集成。

# 2.现代软件发展中静态回归测试选择的扩展研究

1. 回归测试选择(RTS)旨在通过只重新运行受代码更改影响的测试来减少回归测试时间。目前对RTS的研究大致可分为动态技术和静态技术。最近开发的一种名为Ekstazi的动态RTS技术在实践中得到了一些采用，它的评估表明，在较粗的类级粒度上选择测试比在较细的方法级粒度上选择测试提供了更好的结果。
2. 本文首次对静态RTS技术的性能效益及其安全性进行了广泛的研究;如果一项技术选择运行所有可能受代码更改影响的测试，则该技术是安全的。我们实现了两种静态RTS技术，一个类级和一个方法级，并比较了这些技术的几种变体。我们还比较了这些静态RTS技术与Ek- stazi，最先进的，类级别，动态RTS技术。对22个开源项目的985个修订的实验结果表明，类级静态RTS技术可以与Ekstazi相媲美，具有类似的性能优势，但有时存在不安全的风险。相比之下，方法级静态RTS技术的表现则相当糟糕。